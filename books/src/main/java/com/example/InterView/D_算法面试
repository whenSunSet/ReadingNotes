1.插入排序：n*n，在剩下的数字中选一个放入当前已经排好的序列之中。
2.归并排序：nlgn，使用递归将数字分成最底层的单张，然后向上合并1->2->4->8，每一次合并使用选择法将堆合并
3.分治策略：最大子数组问题，nlgn，从最底层开始能找到，能找到左右上一层中最大的子序列，然后将左右中最大子序列和中间比，这样就找到了倒数第三层的最大子序列，这样递归。
4.堆排序：nlgn，先建最大堆(由于一个二叉树 size/2之后是叶子，所以可以对所有非叶子结点进行维护操作(将本点和子结点比较找出最大的然后交换，然后对交换的子节点做这个操作))，n
建好最大堆之后，Root是最大值，所以可以让Root和叶子结点交换，然后对Root结点进行维护操作，就这样遍历所有结点。
5.快速排序：nlgn，先选一个哨兵然后将哨兵和当前序列比较，找出小于等于放前面，大于的放后面。然后对前后的序列进行刚刚的操作，进行递归。
6.随机化快排：当排的序列是从大到小的时候快排速度回退化成n*n，所以如果对哨兵进行随机取，那么其期望速度就是nlgn
7.计数排序：n，用空间换时间，开辟一个序列中最大数字的链表数组，将在每个数字放在以该数字为下标的链表中，重复的就增加链表结点，然后遍历链表数组排序。
8.基数排序：n，将数字的每一位按位数从小到大进行该位所有数字的计数排序。
9.选择算法选择最大最小值：n，在开头或者末尾选一个元素按快排那样找到该元素的位置，如果位置不变说明是最大或最小值，如果变了找最大值的话再后面进行递归，找最小值的话再前面进行递归。
10.二叉搜索树：任何一个结点x，其左子树《=x，其右子树》=x。先中后遍历分别表示父结点何时输出。中序列遍历可以从小到大排序。查找最小最大或者某值可以在lgn结束。
11.红黑树：该树是一种平衡树没有一条路径会比其他路径长出两倍，该树为每个结点有color、key、left、right、parent这几个属性，没有子结点或者父结点则设置为null，该树满足以下几条性质：
    1.根结点是黑色
    2.叶子结点是黑色(叶子结点都为null设置成黑色)
    3.如果一个结点是红色，那么其子结点是黑色。
    4.对每个结点到所有叶结点的路径上，黑色结点的树木是相同的。

    红黑树的好处：
    1.n结点，其最大高度为2lg(n+1)。
    2.对于插入或者删除结点所需要的时间是lgn。
12.动态规划：在分治的方法之上，如果子问题有公共的子子问题，那么就将子子问题保存起来，避免重新计算。一般解决自底向上的最优解问题。
