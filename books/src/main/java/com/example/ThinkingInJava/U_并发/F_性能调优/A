Lock通常会比synchronized高效许多，但是synchronized的代码可读性高，比较简单。
Atomic类只有在非常简单的情况小才有用，通常是你只有一个要被修改的Atomic对象，并且这个对象独立于其他对象。

1.CopyOnWriteArrayList<E>

  ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的；
  在CopyOnWriteArrayList中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，
  读取操作可以安全的执行。当修改完成时，一个原子性的操作将把新的数组换入，使得新的读取操作可以看到这个新的修改。
  这对于读操作远远多于写操作的应用非常适合。CopyOnWriteArrayList的好处之一就是当多个迭代器同时遍历和修改这个列表时，
  不会抛出ConcurrentModificationException；采用类似技术的类还有：CopyOnWriteArraySet，ConcurrentHashMap和ConcurrentLinkedQueue等，
  都允许并发的读取和写入。特别注意：在CopyOnWriteArrayList上获得的Iterator是不能进行set和remove操作的，否则会抛出异常;

2.ReadWriteLock
  维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，
  读取锁可以由多个 reader 线程同时保持。写入锁是独占的。与互斥锁相比，
  读-写锁允许对共享数据进行更高级别的并发访问。虽然一次只有一个线程（writer 线程）可以修改共享数据，
  但在许多情况下，任何数量的线程可以同时读取共享数据（reader 线程），读-写锁利用了这一点。从理论上讲，
  与互斥锁相比，使用读-写锁所允许的并发性增强将带来更大的性能提高。读写锁相对于线程互斥的优势在于高效，
  它不会对两个读线程进行盲目的互斥处理，当读线程数量多于写线程尤其如此，当全是写线程时两者等效。与互斥锁相比，
  使用读-写锁能否提升性能则取决于读写操作期间读取数据相对于修改数据的频率，
  以及数据的争用——即在同一时间试图对该数据执行读取或写入操作的线程数。ReentrantReadWriteLock是它的一个实现类。
  此锁最多支持 65535 个递归写入锁和 65535 个读取锁。试图超出这些限制将导致锁方法抛出 Error。